{
    "myvector": {
        "prefix": "myvector",
        "body": [
            "template<typename T>",
            "struct vec : std::vector<T> {",
            "    using std::vector<T>::vector;",
            "    T& operator[](int index) {",
            "        return this->at(index < 0 ? index + this->size() : index);",
            "    }",
            "    const T& operator[](int index) const {",
            "        return this->at(index < 0 ? index + this->size() : index);",
            "    }",
            "};"
        ],
        "description": "myvector"
    },
    "mod1e97": {
        "prefix": "mod1e97",
        "body": "constexpr int MOD = 1000000007;"
    },
    "mod998244353": {
        "prefix": "mod998244353",
        "body": "constexpr int MOD = 998244353;"
    },
    "minqueue": {
        "prefix": "minqueue",
        "body": "template <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;"
    },
    "ttemplate": {
        "prefix": "ttemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#ifdef LOCAL",
            "#include <debugoutput.h>",
            "#else",
            "#define dbg(...)",
            "#endif",
            "typedef long long ll;",
            "[[maybe_unused]] constexpr int INF = 0x3f3f3f3f;",
            "[[maybe_unused]] constexpr ll LINF = 0x3f3f3f3f3f3f3f3f;",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return b > a ? a = b, 1 : 0; }",
            "template<class A, class B> istream& operator>> (istream& is, pair<A, B>& p) { return is >> p.first >> p.second; }",
            "template<class T> istream& operator>> (istream& is, vector<T>& V) { for (auto& v : V) is >> v; return is; }",
            "#define rep(i, a, b) for (int i = int(a); i < int(b); i++)",
            "#define rrep(i, a, b) for (int i = int(a); i >= int(b); i--)",
            "#define all(x) x.begin(), x.end()",
            "#define rall(x) x.rbegin(), x.rend()",
            "#define len(x) (int)(x).size()",
            "#define pii pair<ll, ll>",
            "#define pb push_back",
            "#define vec vector",
            "",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "signed main() {",
            "#ifndef LOCAL",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "#endif",
            "    cin.exceptions(cin.failbit);",
            "    int T = 1;",
            "    cin >> T;",
            "    for (int t = 1; t <= T; t++) {",
            "        solve();",
            "    }",
            "}"
        ],
        "description": ""
    },
    "template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#ifdef LOCAL",
            "#include <debugoutput.h>",
            "#else",
            "#define dbg(...)",
            "#endif",
            "typedef long long ll;",
            "[[maybe_unused]] constexpr int INF = 0x3f3f3f3f;",
            "[[maybe_unused]] constexpr ll LINF = 0x3f3f3f3f3f3f3f3f;",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return b > a ? a = b, 1 : 0; }",
            "template<class A, class B> istream& operator>> (istream& is, pair<A, B>& p) { return is >> p.first >> p.second; }",
            "template<class T> istream& operator>> (istream& is, vector<T>& V) { for (auto& v : V) is >> v; return is; }",
            "#define rep(i, a, b) for (int i = int(a); i < int(b); i++)",
            "#define rrep(i, a, b) for (int i = int(a); i >= int(b); i--)",
            "#define all(x) x.begin(), x.end()",
            "#define rall(x) x.rbegin(), x.rend()",
            "#define len(x) (int)(x).size()",
            "#define pii pair<ll, ll>",
            "#define pb push_back",
            "#define vec vector",
            "",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "signed main() {",
            "#ifndef LOCAL",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "#endif",
            "    cin.exceptions(cin.failbit);",
            "    solve();",
            "}"
        ],
        "description": "template"
    },
    "timed template": {
        "prefix": "timedtemplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#include <debugoutput.h>",
            "typedef long long ll;",
            "[[maybe_unused]] constexpr int INF = 0x3f3f3f3f;",
            "[[maybe_unused]] constexpr ll LINF = 0x3f3f3f3f3f3f3f3f;",
            "template<class T> bool chmin(T& a, const T& b) { return b < a ? a = b, 1 : 0; }",
            "template<class T> bool chmax(T& a, const T& b) { return b > a ? a = b, 1 : 0; }",
            "#define rep(i, a, b) for (int i = int(a), i##_max_ = int(b); i < i##_max_; i++)",
            "#define rrep(i, a, b) for (int i = int(a), i##_min_ = int(b); i >= i##_min_; i--)",
            "#define all(x) x.begin(), x.end()",
            "#define rall(x) x.rbegin(), x.rend()",
            "#define len(x) (int)(x).size()",
            "#define pii pair<ll, ll>",
            "#define vec vector",
            "",
            "",
            "void solve() {",
            "    $0",
            "}",
            "",
            "int main() {",
            "#ifndef LOCAL",
            "    cin.tie(nullptr)->sync_with_stdio(false);",
            "#endif",
            "    cin.exceptions(cin.failbit);",
            "    auto start_time = chrono::steady_clock::now();",
            "    solve();",
            "    auto end_time = chrono::steady_clock::now();",
            "    cout << \"\\nruntime: \" << fixed << setprecision(2)",
            "        << chrono::duration_cast<chrono::nanoseconds>(end_time - start_time).count() / 1e6",
            "        << \" ms\\n\";",
            "}"
        ],
        "description": ""
    },
    "blank": {
        "prefix": "blank template",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "typedef long long ll;",
            "",
            "int main() {",
            "    $0",
            "",
            "}"
        ],
        "description": "blank c++ template"
    },
    "freopen": {
        "prefix": "openfile",
        "body": [
            "freopen(\"${1:${TM_FILENAME_BASE}}.in\", \"r\", stdin);",
            "freopen(\"${1:${TM_FILENAME_BASE}}.out\", \"w\", stdout);"
        ],
        "description": "use file input output"
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "auto start_time = chrono::steady_clock::now();",
            "auto end_time = chrono::steady_clock::now();",
            "cout << \"\\nruntime: \" << fixed << setprecision(2)",
            "    << chrono::duration_cast<chrono::nanoseconds>(end_time - start_time).count() / 1e6",
            "    << \" ms\\n\";"
        ],
        "description": "timer"
    },
    "timer2": {
        "prefix": "timerAHC",
        "body": [
            "struct Timer {",
            "    chrono::steady_clock::time_point start;",
            "    Timer() { reset(); }",
            "    void reset() { start = chrono::steady_clock::now(); }",
            "    int elapsed() {",
            "        auto end = chrono::steady_clock::now();",
            "        return chrono::duration_cast<chrono::milliseconds>(end - start).count();",
            "    }",
            "    friend string to_string(Timer& t) {",
            "        int time = t.elapsed();",
            "        string res = \"time: \" + to_string(time) + \" ms\";",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "timer for heuristic contest"
    },
    "random": {
        "prefix": "random",
        "body": [
            "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng) // [a, b]",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());"
        ],
        "description": "random"
    },
    "static modular int 32": {
        "prefix": "mint32",
        "body": [
            "typedef struct mint32 {",
            "    uint64_t val;",
            "    constexpr mint32() : val(0) {}",
            "    constexpr mint32(int64_t v) : val((v + MOD) % MOD) {}",
            "    constexpr mint32(int64_t a, int64_t b) : mint32(a) { *this /= mint32(b); } // a * b^-1",
            "    constexpr mint32& operator+=(mint32 const& b) { val += b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint32& operator-=(mint32 const& b) { val += MOD - b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint32& operator*=(mint32 const& b) { val = (val * b.val) % MOD; return *this; }",
            "    friend constexpr mint32 mexp(mint32 b, int64_t e) { mint32 res(1); for (; e; b *= b, e /= 2) if (e & 1) res *= b; return res; }",
            "    friend constexpr mint32 inverse(mint32 a) { return mexp(a, MOD - 2); } // assumes a, MOD coprime",
            "    constexpr mint32& operator/=(mint32 const& b) { return *this *= inverse(b); }",
            "    friend constexpr mint32 operator+(mint32 a, mint32 const b) { return a += b; }",
            "    friend constexpr mint32 operator-(mint32 a, mint32 const b) { return a -= b; }",
            "    friend constexpr mint32 operator-(mint32 const a) { return 0 - a; }",
            "    friend constexpr mint32 operator*(mint32 a, mint32 const b) { return a *= b; }",
            "    friend constexpr mint32 operator/(mint32 a, mint32 const b) { return a /= b; }",
            "    friend constexpr istream& operator>>(istream& is, mint32& a) { int64_t in; is >> in; a = mint32(in); return is; }",
            "    friend constexpr ostream& operator<<(ostream& os, mint32 const& a) { return os << a.val; }",
            "    friend constexpr bool operator==(mint32 const& a, mint32 const& b) { return a.val == b.val; }",
            "    friend constexpr bool operator!=(mint32 const& a, mint32 const& b) { return a.val != b.val; }",
            "} mint;"
        ],
        "description": "static modular int 32"
    },
    "static modular int 2^61 - 1 Mersenne Prime": {
        "prefix": "mint61",
        "body": [
            "constexpr uint64_t MOD = (1LL << 61) - 1;",
            "typedef struct mint61 {",
            "    uint64_t val;",
            "    constexpr mint61() : val(0) {}",
            "    constexpr mint61(int64_t v) : val((v + MOD) % MOD) {}",
            "    constexpr mint61(int64_t a, int64_t b) : mint61(a) { *this /= mint61(b); } // a * b^-1",
            "    constexpr mint61& operator+=(mint61 const& b) { val += b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint61& operator-=(mint61 const& b) { val += MOD - b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint61& operator*=(mint61 const& b) {",
            "        uint64_t l1 = (uint32_t)val, h1 = val >> 32, l2 = (uint32_t)b.val, h2 = b.val >> 32;",
            "        uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
            "        val = (l & MOD) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
            "        val = (val & MOD) + (val >> 61); val = (val & MOD) + (val >> 61); val--;",
            "        return *this;",
            "    }",
            "    friend constexpr mint61 mexp(mint61 b, int64_t e) { mint61 res(1); for (; e; b *= b, e /= 2) if (e & 1) res *= b; return res; }",
            "    friend constexpr mint61 inverse(mint61 a) { return mexp(a, MOD - 2); } // assumes a, MOD coprime",
            "    constexpr mint61 operator/=(mint61 const& b) { return *this *= inverse(b); }",
            "    friend constexpr mint61 operator+(mint61 a, mint61 const b) { return a += b; }",
            "    friend constexpr mint61 operator-(mint61 a, mint61 const b) { return a -= b; }",
            "    friend constexpr mint61 operator-(mint61 const a) { return 0 - a; }",
            "    friend constexpr mint61 operator*(mint61 a, mint61 const b) { return a *= b; }",
            "    friend constexpr mint61 operator/(mint61 a, mint61 const b) { return a /= b; }",
            "    friend constexpr istream& operator>>(istream& is, mint61& a) { int64_t in; is >> in; a = mint61(in); return is; }",
            "    friend constexpr ostream& operator<<(ostream& os, mint61 const& a) { return os << a.val; }",
            "    friend constexpr bool operator==(mint61 const& a, mint61 const& b) { return a.val == b.val; }",
            "    friend constexpr bool operator!=(mint61 const& a, mint61 const& b) { return a.val != b.val; }",
            "} mint;"
        ],
        "description": "static modular int 2^61 - 1 Mersenne Prime"
    },
    "static modular int 64": {
        "prefix": "mint64",
        "body": [
            "typedef struct mint64 {",
            "    uint64_t val;",
            "    constexpr mint64() : val(0) {}",
            "    constexpr mint64(int64_t v) : val((v + MOD) % MOD) {}",
            "    constexpr mint64(int64_t a, int64_t b) : mint64(a) { *this /= mint64(b); } // a * b^-1",
            "    constexpr mint64& operator+=(mint64 const& b) { val += b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint64& operator-=(mint64 const& b) { val += MOD - b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    constexpr mint64& operator*=(mint64 const& b) { // kactl modmul",
            "        int64_t res = this->val * b.val - MOD * uint64_t(1.L / MOD * this->val * b.val);",
            "        val = res + MOD * (res < 0) - MOD * (res >= (int64_t)MOD); return *this;",
            "    }",
            "    friend constexpr mint64 mexp(mint64 b, int64_t e) { mint64 res(1); for (; e; b *= b, e /= 2) if (e & 1) res *= b; return res; }",
            "    friend constexpr mint64 inverse(mint64 a) { return mexp(a, MOD - 2); } // assumes a, MOD coprime",
            "    constexpr mint64 operator/=(mint64 const& b) { return *this *= inverse(b); }",
            "    friend constexpr mint64 operator+(mint64 a, mint64 const b) { return a += b; }",
            "    friend constexpr mint64 operator-(mint64 a, mint64 const b) { return a -= b; }",
            "    friend constexpr mint64 operator-(mint64 const a) { return 0 - a; }",
            "    friend constexpr mint64 operator*(mint64 a, mint64 const b) { return a *= b; }",
            "    friend constexpr mint64 operator/(mint64 a, mint64 const b) { return a /= b; }",
            "    friend constexpr istream& operator>>(istream& is, mint64& a) { int64_t in; is >> in; a = mint64(in); return is; }",
            "    friend constexpr ostream& operator<<(ostream& os, mint64 const& a) { return os << a.val; }",
            "    friend constexpr bool operator==(mint64 const& a, mint64 const& b) { return a.val == b.val; }",
            "    friend constexpr bool operator!=(mint64 const& a, mint64 const& b) { return a.val != b.val; }",
            "} mint;"
        ],
        "description": "static modular int 64"
    },
    "rabin karp polynomial string hash": {
        "prefix": "rabin karp",
        "body": [
            "constexpr uint64_t MOD = (1LL << 61) - 1;",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "uint64_t base = uniform_int_distribution<uint64_t>(331, uint64_t(1e18))(rng) | 1;",
            "struct mint {",
            "    uint64_t val;",
            "    mint() : val(0) {}",
            "    mint(int64_t v) : val((v + MOD) % MOD) {}",
            "    mint(int64_t a, int64_t b) : mint(a) { *this /= mint(b); } // a * b^-1",
            "    mint& operator+=(mint const& b) { val += b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    mint& operator-=(mint const& b) { val += MOD - b.val; if (val >= MOD) val -= MOD; return *this; }",
            "    mint& operator*=(mint const& b) { // kactl modmul",
            "        int64_t res = this->val * b.val - MOD * uint64_t(1.L / MOD * this->val * b.val);",
            "        val = res + MOD * (res < 0) - MOD * (res >= (int64_t)MOD); return *this;",
            "    }",
            "    friend mint mexp(mint b, int64_t e) { mint res(1); for (; e; b *= b, e /= 2) if (e & 1) res *= b; return res; }",
            "    friend mint inverse(mint a) { return mexp(a, MOD - 2); } // assumes a, MOD coprime",
            "    mint& operator/=(mint const& b) { return *this *= inverse(b); }",
            "    friend mint operator+(mint a, mint const b) { return a += b; }",
            "    friend mint operator-(mint a, mint const b) { return a -= b; }",
            "    friend mint operator-(mint const a) { return MOD - a; }",
            "    friend mint operator*(mint a, mint const b) { return a *= b; }",
            "    friend mint operator/(mint a, mint const b) { return a /= b; }",
            "    friend istream& operator>>(istream& is, mint& a) { int64_t in; is >> in; a = mint(in); return is; }",
            "    friend ostream& operator<<(ostream& os, mint const& a) { return os << a.val; }",
            "    friend bool operator==(mint const& a, mint const& b) { return a.val == b.val; }",
            "    friend bool operator!=(mint const& a, mint const& b) { return a.val != b.val; }",
            "};",
            "",
            "mint maxpow;",
            "mint compute_hash(const string& s, int length) {",
            "    maxpow = mexp(mint(base), length);",
            "    mint hash{};",
            "    for (int i = 0; i < length; i++) {",
            "        hash = hash * base + s[i];",
            "    }",
            "    return hash;",
            "}",
            "",
            "mint roll_hash(mint hash, int nxtidx, const string& s, int length) {",
            "    return (hash * base + s[nxtidx]) - (maxpow * s[nxtidx - length]);",
            "}"
        ],
        "description": "rabin karp polynomial string hash"
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "/**",
            " * bitset linear sieve:",
            " * source: https://github.com/mzhang2021/cp-library/blob/master/implementations/math/LinearSieve.h",
            "*/",
            "const int MAX = int(4e6);",
            "bitset<MAX> is_prime;",
            "vector<int> primes;",
            "void sieve() {",
            "    is_prime.set();",
            "    is_prime[0] = is_prime[1] = 0;",
            "    for (int i = 2; i < MAX; i++) {",
            "        if (is_prime[i]) primes.push_back(i);",
            "        for (int j = 0; j < (int)primes.size() && primes[j] <= (MAX - 1) / i; j++) {",
            "            is_prime[i * primes[j]] = 0;",
            "            if (i % primes[j] == 0) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "sieve"
    },
    "Miller-Rabin Prime Check": {
        "prefix": [
            "miller-rabin"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "    ll ret = a * b - M * ull(1.L / M * a * b);",
            "    return ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "    ull ans = 1;",
            "    for (; e; b = modmul(b, b, mod), e /= 2)",
            "        if (e & 1) ans = modmul(ans, b, mod);",
            "    return ans;",
            "}",
            "bool isPrime(ull n) { // Miller-Rabin",
            "    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "    ull A[] = { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 },",
            "        s = __builtin_ctzll(n - 1), d = n >> s;",
            "    for (ull a : A) { // ^ count trailing zeroes",
            "        ull p = modpow(a % n, d, n), i = s;",
            "        while (p != 1 && p != n - 1 && a % n && i--)",
            "            p = modmul(p, p, n);",
            "        if (p != n - 1 && i != s) return 0;",
            "    }",
            "    return 1;",
            "}",
            ""
        ],
        "description": ""
    },
    "Pollard's rho factorize": {
        "prefix": [
            "pollard rho"
        ],
        "body": [
            "typedef unsigned long long ull;",
            "ull modmul(ull a, ull b, ull M) {",
            "    ll ret = a * b - M * ull(1.L / M * a * b);",
            "    return ret + M * (ret < 0) - M * (ret >= (ll)M);",
            "}",
            "ull modpow(ull b, ull e, ull mod) {",
            "    ull ans = 1;",
            "    for (; e; b = modmul(b, b, mod), e /= 2)",
            "        if (e & 1) ans = modmul(ans, b, mod);",
            "    return ans;",
            "}",
            "bool isPrime(ull n) { // Miller-Rabin",
            "    if (n < 2 || n % 6 % 4 != 1) return (n | 1) == 3;",
            "    ull A[] = { 2, 325, 9375, 28178, 450775, 9780504, 1795265022 },",
            "        s = __builtin_ctzll(n - 1), d = n >> s;",
            "    for (ull a : A) { // ^ count trailing zeroes",
            "        ull p = modpow(a % n, d, n), i = s;",
            "        while (p != 1 && p != n - 1 && a % n && i--)",
            "            p = modmul(p, p, n);",
            "        if (p != n - 1 && i != s) return 0;",
            "    }",
            "    return 1;",
            "}",
            "ull pollard(ull n) {",
            "    auto f = [n](ull x) { return modmul(x, x, n) + 1; };",
            "    ull x = 0, y = 0, t = 30, prd = 2, i = 1, q;",
            "    while (t++ % 40 || gcd(prd, n) == 1) {",
            "        if (x == y) x = ++i, y = f(x);",
            "        if ((q = modmul(prd, max(x, y) - min(x, y), n))) prd = q;",
            "        x = f(x), y = f(f(y));",
            "    }",
            "    return gcd(prd, n);",
            "}",
            "vector<ull> factor(ull n) { // Pollard's rho",
            "    if (n == 1) return {};",
            "    if (isPrime(n)) return { n };",
            "    ull x = pollard(n);",
            "    auto l = factor(x), r = factor(n / x);",
            "    l.insert(l.end(), r.begin(), r.end());",
            "    return l;",
            "}",
            ""
        ],
        "description": ""
    },
    "Convex Hull": {
        "prefix": "hull",
        "body": [
            "// kactl convex hull",
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "    typedef Point P;",
            "    T x, y;",
            "    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }",
            "    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }",
            "    P operator+(P p) const { return P(x + p.x, y + p.y); }",
            "    P operator-(P p) const { return P(x - p.x, y - p.y); }",
            "    P operator*(T d) const { return P(x * d, y * d); }",
            "    P operator/(T d) const { return P(x / d, y / d); }",
            "    T dot(P p) const { return x * p.x + y * p.y; }",
            "    T cross(P p) const { return x * p.y - y * p.x; }",
            "    T cross(P a, P b) const { return (a - *this).cross(b - *this); }",
            "    T dist2() const { return x * x + y * y; }",
            "    double dist() const { return sqrt((double)dist2()); }",
            "    // angle to x=axis in interva l [-pi , pi ]",
            "    double angle() const { return atan2(y, x); }",
            "    P unit() const { return *this / dist(); } // makes d is t ()=1",
            "    P perp() const { return P(-y, x); } // rotates +90 degrees",
            "    P normal() const { return perp().unit(); }",
            "    // returns point rotated 'a' radians ccw around the origin",
            "    P rotate(double a) const {",
            "        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "    }",
            "    friend ostream& operator<<(ostream& os, P p) {",
            "        return os << \"(\" << p.x << \",\" << p.y << \")\";",
            "    }",
            "};",
            "",
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "    if (pts.size() <= 1) return pts;",
            "    sort(pts.begin(), pts.end());",
            "    vector<P> h(pts.size() + 1);",
            "    int s = 0, t = 0;",
            "    for (int it = 2; it--; s = --t, reverse(pts.begin(), pts.end()))",
            "        for (P p : pts) {",
            "            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;",
            "            h[t++] = p;",
            "        }",
            "    return { h.begin(), h.begin() + t - (t == 2 && h[0] == h[1]) };",
            "}",
            ""
        ],
        "description": "Convex Hull"
    },
    "Convex Hull Diameter": {
        "prefix": "hull diameter",
        "body": [
            "// kactl hull",
            "template <class T> int sgn(T x) { return (x > 0) - (x < 0); }",
            "template<class T>",
            "struct Point {",
            "    typedef Point P;",
            "    T x, y;",
            "    explicit Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "    bool operator<(P p) const { return tie(x, y) < tie(p.x, p.y); }",
            "    bool operator==(P p) const { return tie(x, y) == tie(p.x, p.y); }",
            "    P operator+(P p) const { return P(x + p.x, y + p.y); }",
            "    P operator-(P p) const { return P(x - p.x, y - p.y); }",
            "    P operator*(T d) const { return P(x * d, y * d); }",
            "    P operator/(T d) const { return P(x / d, y / d); }",
            "    T dot(P p) const { return x * p.x + y * p.y; }",
            "    T cross(P p) const { return x * p.y - y * p.x; }",
            "    T cross(P a, P b) const { return (a - *this).cross(b - *this); }",
            "    T dist2() const { return x * x + y * y; }",
            "    double dist() const { return sqrt((double)dist2()); }",
            "    // angle to x=axis in interva l [=pi , pi ]",
            "    double angle() const { return atan2(y, x); }",
            "    P unit() const { return *this / dist(); } // makes d is t ()=1",
            "    P perp() const { return P(-y, x); } // rotates +90 degrees",
            "    P normal() const { return perp().unit(); }",
            "    // returns point rotated 'a' radians ccw around the origin",
            "    P rotate(double a) const {",
            "        return P(x * cos(a) - y * sin(a), x * sin(a) + y * cos(a));",
            "    }",
            "    friend ostream& operator<<(ostream& os, P p) {",
            "        return os << \"(\" << p.x << \",\" << p.y << \")\";",
            "    }",
            "};",
            "",
            "typedef Point<ll> P;",
            "vector<P> convexHull(vector<P> pts) {",
            "    if (pts.size() <= 1) return pts;",
            "    sort(pts.begin(), pts.end());",
            "    vector<P> h(pts.size() + 1);",
            "    int s = 0, t = 0;",
            "    for (int it = 2; it--; s = --t, reverse(pts.begin(), pts.end()))",
            "        for (P p : pts) {",
            "            while (t >= s + 2 && h[t - 2].cross(h[t - 1], p) <= 0) t--;",
            "            h[t++] = p;",
            "        }",
            "    return { h.begin(), h.begin() + t - (t == 2 && h[0] == h[1]) };",
            "}",
            "",
            "array<P, 2> hullDiameter(vector<P> S) {",
            "    int n = (int)S.size(), j = n < 2 ? 0 : 1;",
            "    pair<ll, array<P, 2>> res({ 0, {S[0], S[0]} });",
            "    for (int i = 0; i < j; i++)",
            "        for (;; j = (j + 1) % n) {",
            "            res = max(res, { (S[i] - S[j]).dist2(), {S[i], S[j]} });",
            "            if ((S[(j + 1) % n] - S[j]).cross(S[i + 1] - S[i]) >= 0)",
            "                break;",
            "        }",
            "    return res.second;",
            "}",
            ""
        ],
        "description": "Convex Hull"
    },
    "powermod": {
        "prefix": [
            "modpow"
        ],
        "body": [
            "ll powmod(ll base, ll exp, ll p = MOD) {",
            "    base %= p;",
            "    ll result = 1;",
            "    while (exp > 0) {",
            "        if (exp & 1) result = (result * base) % p;",
            "        base = (base * base) % p;",
            "        exp >>= 1;",
            "    }",
            "    return result;",
            "}"
        ],
        "description": "a^b % MOD, karatsuba multiplication"
    },
    "Combinatorics2": {
        "prefix": [
            "choose2"
        ],
        "body": [
            "const int MAXN = int(2e6) + 5;",
            "vector<ll> fact;",
            "void initFact(int n = MAXN, int p = MOD) { // run in main",
            "    fact.assign(n + 1, 1);",
            "    for (int i = 2; i <= n; i++) fact[i] = (fact[i - 1] * i) % p;",
            "}",
            "ll powmod(ll a, ll b, ll p = MOD) {",
            "    a %= p;",
            "    if (a == 0) return 0;",
            "    ll res = 1;",
            "    while (b > 0) {",
            "        if (b & 1) res = (res * a) % p;",
            "        a = (a * a) % p;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "ll inv(ll a, ll p = MOD) { return powmod(a, p - 2, p); }",
            "ll ncr(ll n, ll k, ll p = MOD) {",
            "    if (n < k || k < 0) return 0;",
            "    return ((fact[n] * inv(fact[k], p) % p) * inv(fact[n - k], p)) % p;",
            "}",
            "ll stars_bars(ll n, ll k) { return (n == 0 ? 1ll : ncr(n + k - 1, n)); }"
        ],
        "description": "Combinatorics"
    },
    // "Combinatorics": {
    //     "prefix": "choose",
    //     "body": [
    //         "$0const int MAXN = int(4e6) + 5;",
    //         "vector<mint> fact;",
    //         "void initFact() {",
    //         "    fact.assign(MAXN, mint(1));",
    //         "    for(int i = 2; i < MAXN; i++) fact[i] = fact[i - 1] * i;",
    //         "}",
    //         "mint ncr(ll n, ll k) {",
    //         "    if (n < k || k < 0) return mint{};",
    //         "    return fact[n] * inverse(fact[k]) * inverse(fact[n - k]);",
    //         "}",
    //         "mint stars_bars(ll n, ll k) { return (n == 0 ? mint(1) : ncr(n + k - 1, n)); }"
    //     ],
    //     "description": "Combinatorics"
    // },
    "combinatorics": {
        "prefix": [
            "choose",
            "combo"
        ],
        "body": [
            "$1const int MAXN = int(4e6) + 5;",
            "vector<mint> fact, invfact;",
            "void initFact() {",
            "    fact.assign(MAXN, mint(1)), invfact.assign(MAXN, mint(1));",
            "    for (int i = 2; i < MAXN; i++) fact[i] = fact[i - 1] * i;",
            "    invfact[MAXN - 1] = inverse(fact[MAXN - 1]);",
            "    for (int i = MAXN - 2; i >= 0; i--) invfact[i] = invfact[i + 1] * (i + 1);",
            "}",
            "mint ncr(ll n, ll k) {",
            "    if (n < k || k < 0) return mint{};",
            "    return fact[n] * invfact[k] * invfact[n - k];",
            "}",
            "mint stars_bars(ll n, ll k) { return (n == 0 ? mint(1) : ncr(n + k - 1, n)); }"
        ],
        "description": "combinatorics"
    },
    "Union Find": {
        "prefix": [
            "unionfind",
            "dsu"
        ],
        "body": [
            "struct UF {",
            "    vector<int> e;",
            "    UF(int n) : e(n, -1) {}",
            "    bool sameSet(int a, int b) { return find(a) == find(b); }",
            "    int size(int x) { return -e[find(x)]; }",
            "    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }",
            "    bool join(int a, int b) {",
            "        a = find(a), b = find(b);",
            "        if (a == b) return false;",
            "        if (e[a] > e[b]) swap(a, b);",
            "        e[a] += e[b]; e[b] = a;",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Union Find"
    },
    "BinaryIndexedTree": {
        "prefix": [
            "binaryindexedtree",
            "fenwicktree"
        ],
        "body": [
            "struct BIT { // from nyaan's library",
            "    int N;",
            "    vector<ll> data;",
            "    BIT(int size) : N(size + 2), data(size + 3) {}",
            "    ll sum(int k) const { // get sum of [0,k]",
            "        if (k < 0) return ll{};",
            "        ll ret{};",
            "        for (++k; k > 0; k -= k & -k) ret += data[k];",
            "        return ret;",
            "    }",
            "    ll sum(int l, int r) { return sum(r) - sum(l - 1); } // get sum of [l,r]",
            "    void add(int k, ll x) {",
            "        for (++k; k < N; k += k & -k) data[k] += x;",
            "    }",
            "    int lower_bound(ll w) { // minimize `i` s.t. sum(i) >= w",
            "        if (w <= 0) return 0;",
            "        int x = 0;",
            "        for (int k = 1 << (31 - __builtin_clz(N)); k; k >>= 1) {",
            "            if (x + k <= N - 1 && data[x + k] < w) {",
            "                w -= data[x + k];",
            "                x += k;",
            "            }",
            "        }",
            "        return x;",
            "    }",
            "};"
        ],
        "description": "BinaryIndexedTree"
    },
    "Fenwick Tree 2d": {
        "prefix": "fenwicktree2d",
        "body": [
            "struct BIT { // fenwicktree2d",
            "    vector<vector<ll>> bit;",
            "    int n, m;",
            "    BIT(int n, int m) : n(n), m(m), bit(n, vector<ll>(m)) {}",
            "    // 2d sum from (0, 0)",
            "    ll sum(int x, int y) {",
            "        ll ret = 0;",
            "        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)",
            "            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)",
            "                ret += bit[i][j];",
            "        return ret;",
            "    }",
            "    // x2 >= x1, y2 >= y1, make sure x1, y1 are greater than 0",
            "    ll sum2d(int x1, int y1, int x2, int y2) {",
            "        assert(x1 > 0 && y1 > 0);",
            "        x1--, y1--;",
            "        return sum(x2, y2) - sum(x1, y2) - sum(x2, y1) + sum(x1, y1);",
            "    }",
            "    void add(int x, int y, ll delta) {",
            "        for (int i = x; i < n; i = i | (i + 1))",
            "            for (int j = y; j < m; j = j | (j + 1))",
            "                bit[i][j] += delta;",
            "    }",
            "};"
        ],
        "description": "Fenwick Tree 2d"
    },
    "RangeBinaryIndexedTree": {
        "prefix": [
            "rangebinaryindexedtree",
            "rangefenwicktree"
        ],
        "body": [
            "struct BinaryIndexedTree { // from nyaan's library",
            "    int N;",
            "    vector<ll> data;",
            "    BinaryIndexedTree(int size) : N(size + 2), data(size + 3) {}",
            "    ll sum(int k) const { // get sum of [0,k]",
            "        if (k < 0) return ll{};",
            "        ll ret{};",
            "        for (++k; k > 0; k -= k & -k) ret += data[k];",
            "        return ret;",
            "    }",
            "    ll sum(int l, int r) { return sum(r) - sum(l - 1); } // get sum of [l,r]",
            "    void add(int k, ll x) {",
            "        for (++k; k < N; k += k & -k) data[k] += x;",
            "    }",
            "};",
            "struct RangeBIT { // from nyaan's library",
            "    BinaryIndexedTree a, b;",
            "    RangeBIT(int N) : a(N + 1), b(N + 1) {}",
            "    void add(int l, int r, ll x) { // add x to [l, r)",
            "        a.add(l, x);",
            "        a.add(r, -x);",
            "        b.add(l, x * (1 - l));",
            "        b.add(r, x * (r - 1));",
            "    }",
            "    ll sum(int l, int r) { // return sum of [l, r)",
            "        --r, --l;",
            "        return a.sum(r) * r + b.sum(r) - a.sum(l) * l - b.sum(l);",
            "    }",
            "};"
        ],
        "description": "RangeBinaryIndexedTree"
    },
    "Minimal Segment Tree": {
        "prefix": "lazyminimal",
        "body": [
            "/*",
            "    Binary Searchable Iterative Lazy Segment Tree:",
            "    Lazy Add or Lazy Set, Range max or Range min",
            "*/",
            "struct Tree {",
            "    typedef ll T, L;",
            "    static constexpr T def = LLONG_MAX; // change here",
            "    static constexpr L ldef = 0; // change here",
            "    T combine_data(T a, T b) { // change here",
            "        return min(a, b);",
            "    }",
            "    T combine_data_lazy(T a, L b) { // default add, set: return b;",
            "        return a + b;",
            "    }",
            "    L combine_lazy(L a, L b) { // default add, set: return b;",
            "        return a + b;",
            "    }",
            "    int n, h;",
            "    vector<T> data;",
            "    vector<L> lazy;",
            "    Tree(int _n) {",
            "        n = 1, h = 0; while (n < _n) { n <<= 1, h++; }",
            "        data.assign(n << 1, def), lazy.assign(n << 1, ldef);",
            "    }",
            "    Tree(vector<T>& V) : Tree((int)V.size()) {",
            "        for(int i = 0; i < (int)V.size(); i++) data[i + n] = V[i];",
            "        for (int i = n - 1; i; i--) data[i] = combine_data(data[i << 1], data[i << 1 | 1]);",
            "    }",
            "    T reflect(int k) {",
            "        if (lazy[k] == ldef) return data[k];",
            "        return combine_data_lazy(data[k], lazy[k]);",
            "    }",
            "    void eval(int k) {",
            "        if (lazy[k] == ldef) return;",
            "        if (k < n) {",
            "            lazy[k << 1 | 0] = combine_lazy(lazy[k << 1 | 0], lazy[k]);",
            "            lazy[k << 1 | 1] = combine_lazy(lazy[k << 1 | 1], lazy[k]);",
            "        }",
            "        data[k] = reflect(k);",
            "        lazy[k] = ldef;",
            "    }",
            "    void push(int k) { for (int i = h; i; i--) eval(k >> i); }",
            "    void recalc(int k) {",
            "        while (k >>= 1) data[k] = combine_data(reflect(k << 1), reflect(k << 1 | 1));",
            "    }",
            "    void update(int a, int b, L x) {",
            "        if (a >= b) return;",
            "        push(a += n), push(b += n - 1);",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) lazy[l] = combine_lazy(lazy[l], x), l++;",
            "            if (r & 1) --r, lazy[r] = combine_lazy(lazy[r], x);",
            "        }",
            "        recalc(a), recalc(b);",
            "    }",
            "    T query(int a, int b) {",
            "        if (a >= b) return def;",
            "        push(a += n), push(b += n - 1);",
            "        T vl = def, vr = def;",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) vl = combine_data(vl, reflect(l++));",
            "            if (r & 1) vr = combine_data(reflect(--r), vr);",
            "        }",
            "        return combine_data(vl, vr);",
            "    }",
            "};"
        ],
        "description": "segment "
    },
    "Lazy Segment Tree": {
        "prefix": "lazyproportional",
        "body": [
            "/*",
            "    Iterative Proportional Lazy Segment Tree with Add/Set",
            "    Range Operations:",
            "        add(a, b, val) : add val to range [a, b)",
            "        set(a, b, val) : set range [a, b) as val",
            "    Single Operations:",
            "        add_val(a, val) : add val to position a",
            "        set_val(a, val) : set position a to val",
            "    Queries:",
            "        query(a, b) : get query of range [a, b)",
            "        get_val(a) : get value at position a",
            "        lower_bound(a, b, x) : get first idx within range [a, b) >= x or -1",
            "    To Change:",
            "        modify combine_data to min/max, etc",
            "        modify default value 'def'",
            "        if range add/set + range sum, scale lazy value with length",
            "*/",
            "struct Tree {",
            "    typedef ll T; // monoid T",
            "    struct L { // lazy L",
            "        bool isSet = false;",
            "        T val = 0;",
            "        bool operator == (L& o) const { return val == o.val && isSet == o.isSet; }",
            "    };",
            "    static constexpr T def = 0; // change here",
            "    static constexpr L ldef = { false, 0 };",
            "    T combine_data(T a, T b) { // change here",
            "        return max(a, b);",
            "    }",
            "    T combine_data_lazy(T a, L b) { return (b.isSet ? b.val : a + b.val); }",
            "    L combine_lazy(L a, L b) { return (!b.isSet ? a.val += b.val, a : b); }",
            "    L scale_lazy(L a, int len) { // use len for rangesum",
            "        // a.val *= len;",
            "        return a;",
            "    }",
            "    int n, h;",
            "    vector<T> data;",
            "    vector<L> lazy;",
            "    Tree(int _n) {",
            "        n = 1, h = 0; while (n < _n) { n <<= 1, h++; }",
            "        data.assign(n << 1, def), lazy.assign(n << 1, ldef);",
            "    }",
            "    Tree(const vector<T>& v) : Tree((int)v.size()) {",
            "        for (int i = 0; i < int(v.size()); i++) data[n + i] = v[i];",
            "        for (int i = n - 1; i; i--) data[i] = combine_data(data[i << 1], data[i << 1 | 1]);",
            "    }",
            "    inline T reflect(int k, int len) {",
            "        if (lazy[k] == ldef) return data[k];",
            "        return combine_data_lazy(data[k], scale_lazy(lazy[k], len));",
            "    }",
            "    inline void eval(int k, int len) {",
            "        if (lazy[k] == ldef) return;",
            "        if (k < n) {",
            "            lazy[k << 1 | 0] = combine_lazy(lazy[k << 1 | 0], lazy[k]);",
            "            lazy[k << 1 | 1] = combine_lazy(lazy[k << 1 | 1], lazy[k]);",
            "        }",
            "        data[k] = reflect(k, len);",
            "        lazy[k] = ldef;",
            "    }",
            "    inline void push(int k) {",
            "        for (int i = h, len = 1 << h; i; i--, len >>= 1) eval(k >> i, len);",
            "    }",
            "    inline void recalc(int k) {",
            "        int len = 1;",
            "        while (k >>= 1) {",
            "            data[k] = combine_data(reflect(k << 1, len), reflect(k << 1 | 1, len));",
            "            len <<= 1;",
            "        }",
            "    }",
            "    void update(int a, int b, L x) {",
            "        if (a >= b) return;",
            "        push(a += n), push(b += n - 1);",
            "        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
            "            if (l & 1) lazy[l] = combine_lazy(lazy[l], x), l++;",
            "            if (r & 1) --r, lazy[r] = combine_lazy(lazy[r], x);",
            "        }",
            "        recalc(a), recalc(b);",
            "    }",
            "    void add(int a, int b, T val) { update(a, b, { false, val }); }",
            "    void set(int a, int b, T val) { update(a, b, { true, val }); }",
            "    T query(int a, int b) {",
            "        if (a >= b) return def;",
            "        push(a += n), push(b += n - 1);",
            "        T vl = def, vr = def;",
            "        for (int l = a, r = b + 1, len = 1; l < r; l >>= 1, r >>= 1, len <<= 1) {",
            "            if (l & 1) vl = combine_data(vl, reflect(l++, len));",
            "            if (r & 1) vr = combine_data(reflect(--r, len), vr);",
            "        }",
            "        return combine_data(vl, vr);",
            "    }",
            "    void set_val(int a, T x) {",
            "        push(a += n);",
            "        data[a] = x;",
            "        lazy[a] = ldef;",
            "        recalc(a);",
            "    }",
            "    void add_val(int a, T x) {",
            "        push(a += n);",
            "        data[a] += x;",
            "        lazy[a] = ldef;",
            "        recalc(a);",
            "    }",
            "    T get_val(int a) {",
            "        push(a += n);",
            "        return reflect(a, 1);",
            "    }",
            "    int lower_bound(int a, int b, T x) { return lower_bound(a, b, x, 1, 0, n); }",
            "    int lower_bound(int a, int b, T x, int k, int l, int r) { // default: find leftmost index >= x",
            "        eval(k, r - l);",
            "        if (data[k] < x || r <= a || b <= l) return -1;",
            "        if (k >= n) return k - n;",
            "        int vl = lower_bound(a, b, x, k << 1, l, (l + r) / 2);",
            "        if (vl != -1) {",
            "            return vl;",
            "        } else {",
            "            return lower_bound(a, b, x, k << 1 | 1, (l + r) / 2, r);",
            "        }",
            "    }",
            "    void debug() { // prints all ranges, for debugging",
            "        auto interval = [&](int i, auto&& interval) -> pair<int, int> {",
            "            if (i >= n) return { i - n, i - n + 1 };",
            "            pair<int, int> l = interval(i * 2, interval);",
            "            pair<int, int> r = interval(i * 2 + 1, interval);",
            "            if (l.second != r.first) return { -1, -1 };",
            "            return { l.first, r.second };",
            "            };",
            "        for (int i = 1; i < 2 * n; i++) {",
            "            auto res = interval(i, interval);",
            "            cout << i << \": [\" << res.first << \", \" << res.second << \") \" << data[i];",
            "            if (i < n) cout << \" {\" << lazy[i].isSet << \" \" << lazy[i].val << \"}\";",
            "            cout << '\\n';",
            "        }",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "Lazy Segment Tree"
    },
    "segment tree": {
        "prefix": "segtree",
        "body": [
            "struct Tree {",
            "    typedef ll T;",
            "    static constexpr T unit = LLONG_MIN;",
            "    int n;",
            "    vector<T> data;",
            "    T combine(T a, T b) {",
            "        return max(a, b);",
            "    }",
            "    Tree(int _n) {",
            "        n = 1; while (n < _n) n <<= 1;",
            "        data.assign(n * 2, unit);",
            "    }",
            "    Tree(vector<T>& v) : Tree(int(v.size())) {",
            "        for (int i = 0; i < int(v.size()); i++) data[i + n] = v[i];",
            "        for (int i = n - 1; i > 0; i--) data[i] = combine(data[i << 1], data[i << 1 | 1]);",
            "    }",
            "    void update(int pos, T val) {",
            "        for (data[pos += n] = val; pos >>= 1; )",
            "            data[pos] = combine(data[pos << 1], data[pos << 1 | 1]);",
            "    }",
            "    T query(int b, int e) { // [b, e)",
            "        T ra = unit, rb = unit;",
            "        for (b += n, e += n; b < e; b >>= 1, e >>= 1) {",
            "            if (b & 1) ra = combine(ra, data[b++]);",
            "            if (e & 1) rb = combine(data[--e], rb);",
            "        }",
            "        return combine(ra, rb);",
            "    }",
            "    /*  default: for max find first idx within [a, b) >= val */",
            "    int lower_bound(int a, int b, T val) {",
            "        int l = 0, r = n, node = 1;",
            "        if (data[node] < val || a > r || b < l) return -1;",
            "        while (node < n) {",
            "            node *= 2;",
            "            int mid = l + (r - l) / 2;",
            "            if (mid >= a && l <= b && data[node] >= val) {",
            "                r = mid;",
            "            } else {",
            "                l = mid;",
            "                if (r < a || l > b || data[++node] < val) return -1;",
            "            }",
            "        }",
            "        return node - n;",
            "    }",
            "    inline T operator[] (int i) { return data[i + n]; }",
            "    void debug() {",
            "        auto interval = [&](int i, auto&& interval) -> pair<int, int> {",
            "            if (i >= n) return { i - n, i - n + 1 };",
            "            pair<int, int> l = interval(i * 2, interval);",
            "            pair<int, int> r = interval(i * 2 + 1, interval);",
            "            if (l.second != r.first) return { -1, -1 };",
            "            return { l.first, r.second };",
            "        };",
            "        for (int i = 1; i < 2 * n; i++) {",
            "            auto res = interval(i, interval);",
            "            cout << i << \": [\" << res.first << \", \" << res.second << \") \" << data[i];",
            "            cout << '\\n';",
            "        }",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "segment tree"
    },
    "TwoSat": {
        "prefix": "twosat",
        "body": [
            "/**",
            " * Author: Emil Lenngren, Simon Lindholm",
            " * Date: 2011-11-29",
            " * License: CC0",
            " * Source: folklore",
            " * Description: Calculates a valid assignment to boolean variables a, b, c,... to a 2-SAT problem,",
            " * so that an expression of the type $(a\\|\\|b)\\&\\&(!a\\|\\|c)\\&\\&(d\\|\\|!b)\\&\\&...$ becomes true, or reports that it is unsatisfiable.",
            " * Negated variables are represented by bit-inversions (\\texttt{\\tilde{}x}).",
            " * Usage:",
            " *  TwoSat ts(number of boolean variables);",
            " *  ts.addOR(0, \\tilde3); // Var 0 is true or var 3 is false",
            " *  ts.setValue(2); // Var 2 is true",
            " *  ts.solve(); // Returns true iff it is solvable",
            " *  ts.values[0..N-1] holds the assigned values to the vars",
            " * Time: O(N+E), where N is the number of boolean variables, and E is the number of clauses.",
            " * Status: stress-tested",
            " */",
            "struct TwoSat { // Kactl twosat",
            "    int N;",
            "    vector<vi> gr;",
            "    vi values; // 0 = false, 1 = true",
            "",
            "    TwoSat(int n = 0) : N(n), gr(n << 1) {}",
            "",
            "    int addVar() { // (optional)",
            "        gr.emplace_back();",
            "        gr.emplace_back();",
            "        return N++;",
            "    }",
            "",
            "    void addOR(int f, int j) {",
            "        f = max(f << 1, -1 - (f << 1));",
            "        j = max(j << 1, -1 - (j << 1));",
            "        gr[f].push_back(j ^ 1);",
            "        gr[j].push_back(f ^ 1);",
            "    }",
            "    void setValue(int x) { addOR(x, x); }",
            "    void addIMPLIES(int f, int j) { addOR(~f, j); }",
            "",
            "    void atMostOne(const vi& li) { // (optional)",
            "        if (len(li) <= 1) return;",
            "        int cur = ~li[0];",
            "        rep(i, 2, len(li)) {",
            "            int next = addVar();",
            "            addOR(cur, ~li[i]);",
            "            addOR(cur, next);",
            "            addOR(~li[i], next);",
            "            cur = ~next;",
            "        }",
            "        addOR(cur, ~li[1]);",
            "    }",
            "",
            "    vi val, comp, z; int time = 0;",
            "    int dfs(int i) {",
            "        int low = val[i] = ++time, x; z.push_back(i);",
            "        for (int e : gr[i]) if (!comp[e])",
            "            low = min(low, val[e] ? : dfs(e));",
            "        if (low == val[i]) do {",
            "            x = z.back(); z.pop_back();",
            "            comp[x] = low;",
            "            if (values[x >> 1] == -1)",
            "                values[x >> 1] = x & 1;",
            "        } while (x != i);",
            "        return val[i] = low;",
            "    }",
            "",
            "    bool solve() {",
            "        values.assign(N, -1);",
            "        val.assign(N << 1, 0); comp = val;",
            "        rep(i, 0, N << 1) if (!comp[i]) dfs(i);",
            "        rep(i, 0, N) if (comp[2 * i] == comp[i << 1 | 1]) return 0;",
            "        return 1;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "Ordered set": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "template <class T> using ord_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "template <class K, class V> using ord_map = tree<K, V, less<K>, rb_tree_tag, tree_order_statistics_node_update>;"
        ]
    },
    "kDTree": {
        "prefix": "kdtree",
        "body": [
            "using T = array<int, 3>;",
            "struct kDTree { // from tatyam https://trap.jp/post/1489/",
            "    using Iter = vector<T>::iterator;",
            "    kDTree* l = nullptr, * r = nullptr;",
            "    int xmin = INT_MAX, xmax = INT_MIN, ymin = INT_MAX, ymax = INT_MIN;",
            "    ll sum = 0;",
            "    kDTree(Iter begin, Iter end, bool divx = true) {",
            "        for (auto p = begin; p != end; p++) {",
            "            auto [x, y, w] = *p;",
            "            chmin(xmin, x);",
            "            chmax(xmax, x);",
            "            chmin(ymin, y);",
            "            chmax(ymax, y);",
            "            sum += w;",
            "        }",
            "        const int size = int(end - begin);",
            "        if (size <= 1) return;",
            "        auto cen = begin + size / 2;",
            "        if (divx) {",
            "            nth_element(begin, cen, end, [](T& a, T& b) { return a[0] < b[0]; });",
            "        } else {",
            "            nth_element(begin, cen, end, [](T& a, T& b) { return a[1] < b[1]; });",
            "        }",
            "        l = new kDTree(begin, cen, !divx);",
            "        r = new kDTree(cen, end, !divx);",
            "    }",
            "    // [-INF, x] * [-INF, y] ",
            "    // get the weights of the points in the range [-INF, x] * [-INF, y]",
            "    ll get(int x, int y) const {",
            "        // [xmin, xmax] * [ymin, ymax]  [-INF, x] * [-INF, y] ",
            "        // no intersection between [xmin, xmax] * [ymin, ymax] and [-INF, x] * [-INF, y]",
            "        if (x < xmin || y < ymin) return 0;",
            "",
            "        // [xmin, xmax] * [ymin, ymax]  [-INF, x] * [-INF, y] ",
            "        // the whole range [xmin, xmax] * [ymin, ymax] is within [-INF, x] * [-INF, y]",
            "        if (xmax <= x && ymax <= y) return sum;",
            "",
            "        // [xmin, xmax] * [ymin, ymax]  [x1, x2] * [y1, y2]  -> ",
            "        // part of the range [xmin, xmax] * [ymin, ymax] is within [x1, x2] * [y1, y2] -> child evaluates",
            "        return l->get(x, y) + r->get(x, y);",
            "    }",
            "};"
        ],
        "description": "kDTree"
    },
    "segment tree beats": {
        "prefix": "beats",
        "body": [
            "/**",
            " * @brief Range Chmin Chmax Add Update Range Min Max Sum Segment Tree Beats!",
            " * @author nyaan https://nyaannyaan.github.io/library/segment-tree/segment-tree-beats.hpp",
            " * range_chmin(l, r, x)  for a_i in [l, r): a_i = min(a_i, x)",
            " * range_chmax(l, r, x)  for a_i in [l, r): a_i = max(a_i, x)",
            " * range_add(l, r, x)    for a_i in [l, r): a_i += x",
            " * range_update(l, r, x) for a_i in [l, r): a_i = x",
            " * range_min(l, r)",
            " * range_max(l, r)",
            " * range_sum(l, r)",
            " */",
            "struct AngelBeats {",
            "    static constexpr ll INF = numeric_limits<ll>::max() / 2.1;",
            "    struct alignas(32) Node {",
            "        ll sum = 0, g1 = 0, l1 = 0;",
            "        ll g2 = -INF, gc = 1, l2 = INF, lc = 1, add = 0;",
            "    };",
            "    vector<Node> v;",
            "    ll n, log;",
            "    AngelBeats() {}",
            "    AngelBeats(int _n) : AngelBeats(vector<ll>(_n)) {}",
            "    AngelBeats(const vector<ll>& vc) {",
            "        n = 1, log = 0;",
            "        while (n < (int)vc.size()) n <<= 1, log++;",
            "        v.resize(2 * n);",
            "        for (ll i = 0; i < (int)vc.size(); ++i) {",
            "            v[i + n].sum = v[i + n].g1 = v[i + n].l1 = vc[i];",
            "        }",
            "        for (ll i = n - 1; i; --i) update(i);",
            "    }",
            "    void range_chmin(int l, int r, ll x) { inner_apply<1>(l, r, x); }",
            "    void range_chmax(int l, int r, ll x) { inner_apply<2>(l, r, x); }",
            "    void range_add(int l, int r, ll x) { inner_apply<3>(l, r, x); }",
            "    void range_update(int l, int r, ll x) { inner_apply<4>(l, r, x); }",
            "    ll range_min(int l, int r) { return inner_fold<1>(l, r); }",
            "    ll range_max(int l, int r) { return inner_fold<2>(l, r); }",
            "    ll range_sum(int l, int r) { return inner_fold<3>(l, r); }",
            "private:",
            "    void update(int k) {",
            "        Node& p = v[k];",
            "        Node& l = v[k * 2 + 0];",
            "        Node& r = v[k * 2 + 1];",
            "        p.sum = l.sum + r.sum;",
            "        if (l.g1 == r.g1) {",
            "            p.g1 = l.g1;",
            "            p.g2 = max(l.g2, r.g2);",
            "            p.gc = l.gc + r.gc;",
            "        } else {",
            "            bool f = l.g1 > r.g1;",
            "            p.g1 = f ? l.g1 : r.g1;",
            "            p.gc = f ? l.gc : r.gc;",
            "            p.g2 = max(f ? r.g1 : l.g1, f ? l.g2 : r.g2);",
            "        }",
            "        if (l.l1 == r.l1) {",
            "            p.l1 = l.l1;",
            "            p.l2 = min(l.l2, r.l2);",
            "            p.lc = l.lc + r.lc;",
            "        } else {",
            "            bool f = l.l1 < r.l1;",
            "            p.l1 = f ? l.l1 : r.l1;",
            "            p.lc = f ? l.lc : r.lc;",
            "            p.l2 = min(f ? r.l1 : l.l1, f ? l.l2 : r.l2);",
            "        }",
            "    }",
            "    void push_add(int k, ll x) {",
            "        Node& p = v[k];",
            "        p.sum += x << (log + __builtin_clz(k) - 31);",
            "        p.g1 += x;",
            "        p.l1 += x;",
            "        if (p.g2 != -INF) p.g2 += x;",
            "        if (p.l2 != INF) p.l2 += x;",
            "        p.add += x;",
            "    }",
            "    void push_min(int k, ll x) {",
            "        Node& p = v[k];",
            "        p.sum += (x - p.g1) * p.gc;",
            "        if (p.l1 == p.g1) p.l1 = x;",
            "        if (p.l2 == p.g1) p.l2 = x;",
            "        p.g1 = x;",
            "    }",
            "    void push_max(int k, ll x) {",
            "        Node& p = v[k];",
            "        p.sum += (x - p.l1) * p.lc;",
            "        if (p.g1 == p.l1) p.g1 = x;",
            "        if (p.g2 == p.l1) p.g2 = x;",
            "        p.l1 = x;",
            "    }",
            "    void push(int k) {",
            "        Node& p = v[k];",
            "        if (p.add != 0) {",
            "            push_add(k * 2 + 0, p.add);",
            "            push_add(k * 2 + 1, p.add);",
            "            p.add = 0;",
            "        }",
            "        if (p.g1 < v[k * 2 + 0].g1) push_min(k * 2 + 0, p.g1);",
            "        if (p.l1 > v[k * 2 + 0].l1) push_max(k * 2 + 0, p.l1);",
            "",
            "        if (p.g1 < v[k * 2 + 1].g1) push_min(k * 2 + 1, p.g1);",
            "        if (p.l1 > v[k * 2 + 1].l1) push_max(k * 2 + 1, p.l1);",
            "    }",
            "    void subtree_chmin(int k, ll x) {",
            "        if (v[k].g1 <= x) return;",
            "        if (v[k].g2 < x) {",
            "            push_min(k, x);",
            "            return;",
            "        }",
            "        push(k);",
            "        subtree_chmin(k * 2 + 0, x);",
            "        subtree_chmin(k * 2 + 1, x);",
            "        update(k);",
            "    }",
            "    void subtree_chmax(int k, ll x) {",
            "        if (x <= v[k].l1) return;",
            "        if (x < v[k].l2) {",
            "            push_max(k, x);",
            "            return;",
            "        }",
            "        push(k);",
            "        subtree_chmax(k * 2 + 0, x);",
            "        subtree_chmax(k * 2 + 1, x);",
            "        update(k);",
            "    }",
            "    template <int cmd> inline void _apply(int k, ll x) {",
            "        if constexpr (cmd == 1) subtree_chmin(k, x);",
            "        if constexpr (cmd == 2) subtree_chmax(k, x);",
            "        if constexpr (cmd == 3) push_add(k, x);",
            "        if constexpr (cmd == 4) subtree_chmin(k, x), subtree_chmax(k, x);",
            "    }",
            "    template <int cmd> void inner_apply(int l, int r, ll x) {",
            "        if (l == r) return;",
            "        l += n, r += n;",
            "        for (int i = log; i >= 1; i--) {",
            "            if (((l >> i) << i) != l) push(l >> i);",
            "            if (((r >> i) << i) != r) push((r - 1) >> i);",
            "        }",
            "        {",
            "            int l2 = l, r2 = r;",
            "            while (l < r) {",
            "                if (l & 1) _apply<cmd>(l++, x);",
            "                if (r & 1) _apply<cmd>(--r, x);",
            "                l >>= 1;",
            "                r >>= 1;",
            "            }",
            "            l = l2;",
            "            r = r2;",
            "        }",
            "        for (int i = 1; i <= log; i++) {",
            "            if (((l >> i) << i) != l) update(l >> i);",
            "            if (((r >> i) << i) != r) update((r - 1) >> i);",
            "        }",
            "    }",
            "    template <int cmd> inline ll e() {",
            "        if constexpr (cmd == 1) return INF;",
            "        if constexpr (cmd == 2) return -INF;",
            "        return 0;",
            "    }",
            "    template <int cmd> inline void op(ll& a, const Node& b) {",
            "        if constexpr (cmd == 1) a = min(a, b.l1);",
            "        if constexpr (cmd == 2) a = max(a, b.g1);",
            "        if constexpr (cmd == 3) a += b.sum;",
            "    }",
            "    template <int cmd> ll inner_fold(int l, int r) {",
            "        if (l == r) return e<cmd>();",
            "        l += n, r += n;",
            "        for (int i = log; i >= 1; i--) {",
            "            if (((l >> i) << i) != l) push(l >> i);",
            "            if (((r >> i) << i) != r) push((r - 1) >> i);",
            "        }",
            "        ll lx = e<cmd>(), rx = e<cmd>();",
            "        while (l < r) {",
            "            if (l & 1) op<cmd>(lx, v[l++]);",
            "            if (r & 1) op<cmd>(rx, v[--r]);",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        if constexpr (cmd == 1) lx = min(lx, rx);",
            "        if constexpr (cmd == 2) lx = max(lx, rx);",
            "        if constexpr (cmd == 3) lx += rx;",
            "        return lx;",
            "    }",
            "};"
        ],
        "description": "segment "
    },
    "Custom Hash": {
        "prefix": "custom hash",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "template<class K, class V> using hashmap = unordered_map<K, V, custom_hash>;",
            "template<class T> using hashset = unordered_set<T, custom_hash>;"
        ],
        "description": "Custom Hash"
    },
    "Coordinate Compression": {
        "prefix": "compress",
        "body": [
            "sort(all(${1:compress}));",
            "$1.erase(unique(all($1)), end($1));$2"
        ],
        "description": "Coordinate Compression"
    }
}
